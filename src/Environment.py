from individual import Individual, IndividualBuilder
from music import *
from midiutil import MIDIFile
import pathlib
import subprocess


def play_generated(notes, durations, individual):
    track = 0
    channel = 0
    time = 0  # In beats
    tempo = 160  # In BPM

    MyMIDI = MIDIFile(1)  # One track, defaults to format 1 (tempo track automatically created)
    MyMIDI.addTempo(track, time, tempo)

    id = individual.id

    for i in range(len(notes)):
        MyMIDI.addNote(track, channel, notes[i], time, durations[i], 127)   # 127 is the dynamic
        time = time + 1

    filename = "../outputs/midi/output_midi_{}_ind{}.mid".format(output_id, id)

    with open(filename, "wb") as output_file:
        MyMIDI.writeFile(output_file)

    subprocess.call("C:/fluidsynth-x64/FluidR3_GM/play.bat {}{}".format(pathlib.Path().absolute().parent, filename[2:]))


def save_generated(notes, duration, individual, score):
    id = individual.id
    parent_ids = individual.parents
    if not parent_ids:
        parent_ids = "X,X"

    filename = "../outputs/notes/output_notes_{}_ind{}_score{}.txt".format(output_id, id, score)

    with open(filename, "w") as output_file:
        output_file.write(" generated by individual #{} son of {} \n".format(id, parent_ids))
        for i in range(len(notes)):
            output_file.write(" {} ".format(notes[i]))
        output_file.write('\n')

        for i in range(len(notes)):
            output_file.write(" {} ".format(duration[i]))
        output_file.write('\n')


def save_genes(individual, score):
    filename = "../outputs/genes/genes_{}_ind{}_score{}.txt".format(output_id, individual.id, score)
    individual.save_genes(filename)


individuals = []
pop_size = 4            # should be multiple of 4
root = C5
scale = MAJOR_SCALE
phrase_length = 8
output_id = 0

# starting population
individual_id = 0
while individual_id < pop_size:
    ind = IndividualBuilder.from_chance(root, scale, phrase_length, individual_id)
    individual_id += 1
    individuals.append({
        "individual": ind,
        "score": None
    })

stop = "y"
while stop == "y":

    # make individuals generate melodies and get scores for each
    for i in range(pop_size):
        notes, durations = individuals[i]['individual'].generate()
        play_generated(notes, durations, individuals[i]['individual'])
        score = int(input('Assign a score to this composition: '))
        individuals[i]['score'] = score
        save_generated(notes, durations, individuals[i]['individual'], score)
        save_genes(individuals[i]['individual'], score)
        output_id += 1

    # sort by score
    individuals = sorted(individuals, key=lambda a: a['score'], reverse=True)

    # making new individuals
    new_individuals = []
    # some from old ones
    for i in range(0, len(individuals)//2, 2):  # i is incremented by 2
        new_individuals.append({
            'individual': IndividualBuilder.from_individuals(individuals[i]['individual'],
                                                             individuals[i + 1]['individual'], individual_id),
            'score': -1
        })
        individual_id += 1

    # some from chance
    for i in range(0, len(individuals)//4):
        new_individuals.append({
            'individual': IndividualBuilder.from_chance(root, scale, phrase_length, individual_id),
            'score': -1
        })
        individual_id += 1

    # adding new individuals in population
    j = 0
    for i in range(0, len(individuals)):
        if not i < len(individuals)//2:
            if j < len(individuals):
                individuals[i] = new_individuals[j]
                j += 1
            else:
                print("something went horribly wrong")

    stop = input('Keep going? ')
